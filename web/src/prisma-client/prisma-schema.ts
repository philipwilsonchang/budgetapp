// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCost {
  count: Int!
}

type AggregateFinancialMonth {
  count: Int!
}

type AggregateFixedCostCategory {
  count: Int!
}

type AggregateFlexCostCategory {
  count: Int!
}

type AggregateMonthlyIncome {
  count: Int!
}

type AggregateRollingCostCategory {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Cost {
  id: ID!
  amount: Float!
  description: String!
  createdAt: DateTime!
  category: FlexCostCategory!
}

type CostConnection {
  pageInfo: PageInfo!
  edges: [CostEdge]!
  aggregate: AggregateCost!
}

input CostCreateInput {
  id: ID
  amount: Float!
  description: String!
  category: FlexCostCategoryCreateOneInput!
}

type CostEdge {
  node: Cost!
  cursor: String!
}

enum CostOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
}

type CostPreviousValues {
  id: ID!
  amount: Float!
  description: String!
  createdAt: DateTime!
}

type CostSubscriptionPayload {
  mutation: MutationType!
  node: Cost
  updatedFields: [String!]
  previousValues: CostPreviousValues
}

input CostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostWhereInput
  AND: [CostSubscriptionWhereInput!]
  OR: [CostSubscriptionWhereInput!]
  NOT: [CostSubscriptionWhereInput!]
}

input CostUpdateInput {
  amount: Float
  description: String
  category: FlexCostCategoryUpdateOneRequiredInput
}

input CostUpdateManyMutationInput {
  amount: Float
  description: String
}

input CostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  category: FlexCostCategoryWhereInput
  AND: [CostWhereInput!]
  OR: [CostWhereInput!]
  NOT: [CostWhereInput!]
}

input CostWhereUniqueInput {
  id: ID
}

scalar DateTime

type FinancialMonth {
  id: ID!
  month: Int!
  year: Int!
  income: Float!
  totalCost: Float!
  remainder: Float!
  closed: Boolean!
}

type FinancialMonthConnection {
  pageInfo: PageInfo!
  edges: [FinancialMonthEdge]!
  aggregate: AggregateFinancialMonth!
}

input FinancialMonthCreateInput {
  id: ID
  month: Int!
  year: Int!
  income: Float!
  totalCost: Float!
  remainder: Float!
  closed: Boolean
}

type FinancialMonthEdge {
  node: FinancialMonth!
  cursor: String!
}

enum FinancialMonthOrderByInput {
  id_ASC
  id_DESC
  month_ASC
  month_DESC
  year_ASC
  year_DESC
  income_ASC
  income_DESC
  totalCost_ASC
  totalCost_DESC
  remainder_ASC
  remainder_DESC
  closed_ASC
  closed_DESC
}

type FinancialMonthPreviousValues {
  id: ID!
  month: Int!
  year: Int!
  income: Float!
  totalCost: Float!
  remainder: Float!
  closed: Boolean!
}

type FinancialMonthSubscriptionPayload {
  mutation: MutationType!
  node: FinancialMonth
  updatedFields: [String!]
  previousValues: FinancialMonthPreviousValues
}

input FinancialMonthSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FinancialMonthWhereInput
  AND: [FinancialMonthSubscriptionWhereInput!]
  OR: [FinancialMonthSubscriptionWhereInput!]
  NOT: [FinancialMonthSubscriptionWhereInput!]
}

input FinancialMonthUpdateInput {
  month: Int
  year: Int
  income: Float
  totalCost: Float
  remainder: Float
  closed: Boolean
}

input FinancialMonthUpdateManyMutationInput {
  month: Int
  year: Int
  income: Float
  totalCost: Float
  remainder: Float
  closed: Boolean
}

input FinancialMonthWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  month: Int
  month_not: Int
  month_in: [Int!]
  month_not_in: [Int!]
  month_lt: Int
  month_lte: Int
  month_gt: Int
  month_gte: Int
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  income: Float
  income_not: Float
  income_in: [Float!]
  income_not_in: [Float!]
  income_lt: Float
  income_lte: Float
  income_gt: Float
  income_gte: Float
  totalCost: Float
  totalCost_not: Float
  totalCost_in: [Float!]
  totalCost_not_in: [Float!]
  totalCost_lt: Float
  totalCost_lte: Float
  totalCost_gt: Float
  totalCost_gte: Float
  remainder: Float
  remainder_not: Float
  remainder_in: [Float!]
  remainder_not_in: [Float!]
  remainder_lt: Float
  remainder_lte: Float
  remainder_gt: Float
  remainder_gte: Float
  closed: Boolean
  closed_not: Boolean
  AND: [FinancialMonthWhereInput!]
  OR: [FinancialMonthWhereInput!]
  NOT: [FinancialMonthWhereInput!]
}

input FinancialMonthWhereUniqueInput {
  id: ID
}

type FixedCostCategory {
  id: ID!
  name: String!
  amount: Float!
}

type FixedCostCategoryConnection {
  pageInfo: PageInfo!
  edges: [FixedCostCategoryEdge]!
  aggregate: AggregateFixedCostCategory!
}

input FixedCostCategoryCreateInput {
  id: ID
  name: String!
  amount: Float!
}

type FixedCostCategoryEdge {
  node: FixedCostCategory!
  cursor: String!
}

enum FixedCostCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  amount_ASC
  amount_DESC
}

type FixedCostCategoryPreviousValues {
  id: ID!
  name: String!
  amount: Float!
}

type FixedCostCategorySubscriptionPayload {
  mutation: MutationType!
  node: FixedCostCategory
  updatedFields: [String!]
  previousValues: FixedCostCategoryPreviousValues
}

input FixedCostCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FixedCostCategoryWhereInput
  AND: [FixedCostCategorySubscriptionWhereInput!]
  OR: [FixedCostCategorySubscriptionWhereInput!]
  NOT: [FixedCostCategorySubscriptionWhereInput!]
}

input FixedCostCategoryUpdateInput {
  name: String
  amount: Float
}

input FixedCostCategoryUpdateManyMutationInput {
  name: String
  amount: Float
}

input FixedCostCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [FixedCostCategoryWhereInput!]
  OR: [FixedCostCategoryWhereInput!]
  NOT: [FixedCostCategoryWhereInput!]
}

input FixedCostCategoryWhereUniqueInput {
  id: ID
  name: String
}

type FlexCostCategory {
  id: ID!
  name: String!
  limit: Float!
}

type FlexCostCategoryConnection {
  pageInfo: PageInfo!
  edges: [FlexCostCategoryEdge]!
  aggregate: AggregateFlexCostCategory!
}

input FlexCostCategoryCreateInput {
  id: ID
  name: String!
  limit: Float!
}

input FlexCostCategoryCreateOneInput {
  create: FlexCostCategoryCreateInput
  connect: FlexCostCategoryWhereUniqueInput
}

type FlexCostCategoryEdge {
  node: FlexCostCategory!
  cursor: String!
}

enum FlexCostCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  limit_ASC
  limit_DESC
}

type FlexCostCategoryPreviousValues {
  id: ID!
  name: String!
  limit: Float!
}

type FlexCostCategorySubscriptionPayload {
  mutation: MutationType!
  node: FlexCostCategory
  updatedFields: [String!]
  previousValues: FlexCostCategoryPreviousValues
}

input FlexCostCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FlexCostCategoryWhereInput
  AND: [FlexCostCategorySubscriptionWhereInput!]
  OR: [FlexCostCategorySubscriptionWhereInput!]
  NOT: [FlexCostCategorySubscriptionWhereInput!]
}

input FlexCostCategoryUpdateDataInput {
  name: String
  limit: Float
}

input FlexCostCategoryUpdateInput {
  name: String
  limit: Float
}

input FlexCostCategoryUpdateManyMutationInput {
  name: String
  limit: Float
}

input FlexCostCategoryUpdateOneRequiredInput {
  create: FlexCostCategoryCreateInput
  update: FlexCostCategoryUpdateDataInput
  upsert: FlexCostCategoryUpsertNestedInput
  connect: FlexCostCategoryWhereUniqueInput
}

input FlexCostCategoryUpsertNestedInput {
  update: FlexCostCategoryUpdateDataInput!
  create: FlexCostCategoryCreateInput!
}

input FlexCostCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  limit: Float
  limit_not: Float
  limit_in: [Float!]
  limit_not_in: [Float!]
  limit_lt: Float
  limit_lte: Float
  limit_gt: Float
  limit_gte: Float
  AND: [FlexCostCategoryWhereInput!]
  OR: [FlexCostCategoryWhereInput!]
  NOT: [FlexCostCategoryWhereInput!]
}

input FlexCostCategoryWhereUniqueInput {
  id: ID
  name: String
}

scalar Long

type MonthlyIncome {
  id: ID!
  amount: Float!
}

type MonthlyIncomeConnection {
  pageInfo: PageInfo!
  edges: [MonthlyIncomeEdge]!
  aggregate: AggregateMonthlyIncome!
}

input MonthlyIncomeCreateInput {
  id: ID
  amount: Float!
}

type MonthlyIncomeEdge {
  node: MonthlyIncome!
  cursor: String!
}

enum MonthlyIncomeOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
}

type MonthlyIncomePreviousValues {
  id: ID!
  amount: Float!
}

type MonthlyIncomeSubscriptionPayload {
  mutation: MutationType!
  node: MonthlyIncome
  updatedFields: [String!]
  previousValues: MonthlyIncomePreviousValues
}

input MonthlyIncomeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MonthlyIncomeWhereInput
  AND: [MonthlyIncomeSubscriptionWhereInput!]
  OR: [MonthlyIncomeSubscriptionWhereInput!]
  NOT: [MonthlyIncomeSubscriptionWhereInput!]
}

input MonthlyIncomeUpdateInput {
  amount: Float
}

input MonthlyIncomeUpdateManyMutationInput {
  amount: Float
}

input MonthlyIncomeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [MonthlyIncomeWhereInput!]
  OR: [MonthlyIncomeWhereInput!]
  NOT: [MonthlyIncomeWhereInput!]
}

input MonthlyIncomeWhereUniqueInput {
  id: ID
}

type Mutation {
  createCost(data: CostCreateInput!): Cost!
  updateCost(data: CostUpdateInput!, where: CostWhereUniqueInput!): Cost
  updateManyCosts(data: CostUpdateManyMutationInput!, where: CostWhereInput): BatchPayload!
  upsertCost(where: CostWhereUniqueInput!, create: CostCreateInput!, update: CostUpdateInput!): Cost!
  deleteCost(where: CostWhereUniqueInput!): Cost
  deleteManyCosts(where: CostWhereInput): BatchPayload!
  createFinancialMonth(data: FinancialMonthCreateInput!): FinancialMonth!
  updateFinancialMonth(data: FinancialMonthUpdateInput!, where: FinancialMonthWhereUniqueInput!): FinancialMonth
  updateManyFinancialMonths(data: FinancialMonthUpdateManyMutationInput!, where: FinancialMonthWhereInput): BatchPayload!
  upsertFinancialMonth(where: FinancialMonthWhereUniqueInput!, create: FinancialMonthCreateInput!, update: FinancialMonthUpdateInput!): FinancialMonth!
  deleteFinancialMonth(where: FinancialMonthWhereUniqueInput!): FinancialMonth
  deleteManyFinancialMonths(where: FinancialMonthWhereInput): BatchPayload!
  createFixedCostCategory(data: FixedCostCategoryCreateInput!): FixedCostCategory!
  updateFixedCostCategory(data: FixedCostCategoryUpdateInput!, where: FixedCostCategoryWhereUniqueInput!): FixedCostCategory
  updateManyFixedCostCategories(data: FixedCostCategoryUpdateManyMutationInput!, where: FixedCostCategoryWhereInput): BatchPayload!
  upsertFixedCostCategory(where: FixedCostCategoryWhereUniqueInput!, create: FixedCostCategoryCreateInput!, update: FixedCostCategoryUpdateInput!): FixedCostCategory!
  deleteFixedCostCategory(where: FixedCostCategoryWhereUniqueInput!): FixedCostCategory
  deleteManyFixedCostCategories(where: FixedCostCategoryWhereInput): BatchPayload!
  createFlexCostCategory(data: FlexCostCategoryCreateInput!): FlexCostCategory!
  updateFlexCostCategory(data: FlexCostCategoryUpdateInput!, where: FlexCostCategoryWhereUniqueInput!): FlexCostCategory
  updateManyFlexCostCategories(data: FlexCostCategoryUpdateManyMutationInput!, where: FlexCostCategoryWhereInput): BatchPayload!
  upsertFlexCostCategory(where: FlexCostCategoryWhereUniqueInput!, create: FlexCostCategoryCreateInput!, update: FlexCostCategoryUpdateInput!): FlexCostCategory!
  deleteFlexCostCategory(where: FlexCostCategoryWhereUniqueInput!): FlexCostCategory
  deleteManyFlexCostCategories(where: FlexCostCategoryWhereInput): BatchPayload!
  createMonthlyIncome(data: MonthlyIncomeCreateInput!): MonthlyIncome!
  updateMonthlyIncome(data: MonthlyIncomeUpdateInput!, where: MonthlyIncomeWhereUniqueInput!): MonthlyIncome
  updateManyMonthlyIncomes(data: MonthlyIncomeUpdateManyMutationInput!, where: MonthlyIncomeWhereInput): BatchPayload!
  upsertMonthlyIncome(where: MonthlyIncomeWhereUniqueInput!, create: MonthlyIncomeCreateInput!, update: MonthlyIncomeUpdateInput!): MonthlyIncome!
  deleteMonthlyIncome(where: MonthlyIncomeWhereUniqueInput!): MonthlyIncome
  deleteManyMonthlyIncomes(where: MonthlyIncomeWhereInput): BatchPayload!
  createRollingCostCategory(data: RollingCostCategoryCreateInput!): RollingCostCategory!
  updateRollingCostCategory(data: RollingCostCategoryUpdateInput!, where: RollingCostCategoryWhereUniqueInput!): RollingCostCategory
  updateManyRollingCostCategories(data: RollingCostCategoryUpdateManyMutationInput!, where: RollingCostCategoryWhereInput): BatchPayload!
  upsertRollingCostCategory(where: RollingCostCategoryWhereUniqueInput!, create: RollingCostCategoryCreateInput!, update: RollingCostCategoryUpdateInput!): RollingCostCategory!
  deleteRollingCostCategory(where: RollingCostCategoryWhereUniqueInput!): RollingCostCategory
  deleteManyRollingCostCategories(where: RollingCostCategoryWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  cost(where: CostWhereUniqueInput!): Cost
  costs(where: CostWhereInput, orderBy: CostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cost]!
  costsConnection(where: CostWhereInput, orderBy: CostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostConnection!
  financialMonth(where: FinancialMonthWhereUniqueInput!): FinancialMonth
  financialMonths(where: FinancialMonthWhereInput, orderBy: FinancialMonthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FinancialMonth]!
  financialMonthsConnection(where: FinancialMonthWhereInput, orderBy: FinancialMonthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FinancialMonthConnection!
  fixedCostCategory(where: FixedCostCategoryWhereUniqueInput!): FixedCostCategory
  fixedCostCategories(where: FixedCostCategoryWhereInput, orderBy: FixedCostCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FixedCostCategory]!
  fixedCostCategoriesConnection(where: FixedCostCategoryWhereInput, orderBy: FixedCostCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FixedCostCategoryConnection!
  flexCostCategory(where: FlexCostCategoryWhereUniqueInput!): FlexCostCategory
  flexCostCategories(where: FlexCostCategoryWhereInput, orderBy: FlexCostCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FlexCostCategory]!
  flexCostCategoriesConnection(where: FlexCostCategoryWhereInput, orderBy: FlexCostCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FlexCostCategoryConnection!
  monthlyIncome(where: MonthlyIncomeWhereUniqueInput!): MonthlyIncome
  monthlyIncomes(where: MonthlyIncomeWhereInput, orderBy: MonthlyIncomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MonthlyIncome]!
  monthlyIncomesConnection(where: MonthlyIncomeWhereInput, orderBy: MonthlyIncomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MonthlyIncomeConnection!
  rollingCostCategory(where: RollingCostCategoryWhereUniqueInput!): RollingCostCategory
  rollingCostCategories(where: RollingCostCategoryWhereInput, orderBy: RollingCostCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RollingCostCategory]!
  rollingCostCategoriesConnection(where: RollingCostCategoryWhereInput, orderBy: RollingCostCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RollingCostCategoryConnection!
  node(id: ID!): Node
}

type RollingCostCategory {
  id: ID!
  name: String!
  monthlyLimit: Float!
  totalLimit: Float!
}

type RollingCostCategoryConnection {
  pageInfo: PageInfo!
  edges: [RollingCostCategoryEdge]!
  aggregate: AggregateRollingCostCategory!
}

input RollingCostCategoryCreateInput {
  id: ID
  name: String!
  monthlyLimit: Float!
  totalLimit: Float!
}

type RollingCostCategoryEdge {
  node: RollingCostCategory!
  cursor: String!
}

enum RollingCostCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  monthlyLimit_ASC
  monthlyLimit_DESC
  totalLimit_ASC
  totalLimit_DESC
}

type RollingCostCategoryPreviousValues {
  id: ID!
  name: String!
  monthlyLimit: Float!
  totalLimit: Float!
}

type RollingCostCategorySubscriptionPayload {
  mutation: MutationType!
  node: RollingCostCategory
  updatedFields: [String!]
  previousValues: RollingCostCategoryPreviousValues
}

input RollingCostCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RollingCostCategoryWhereInput
  AND: [RollingCostCategorySubscriptionWhereInput!]
  OR: [RollingCostCategorySubscriptionWhereInput!]
  NOT: [RollingCostCategorySubscriptionWhereInput!]
}

input RollingCostCategoryUpdateInput {
  name: String
  monthlyLimit: Float
  totalLimit: Float
}

input RollingCostCategoryUpdateManyMutationInput {
  name: String
  monthlyLimit: Float
  totalLimit: Float
}

input RollingCostCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  monthlyLimit: Float
  monthlyLimit_not: Float
  monthlyLimit_in: [Float!]
  monthlyLimit_not_in: [Float!]
  monthlyLimit_lt: Float
  monthlyLimit_lte: Float
  monthlyLimit_gt: Float
  monthlyLimit_gte: Float
  totalLimit: Float
  totalLimit_not: Float
  totalLimit_in: [Float!]
  totalLimit_not_in: [Float!]
  totalLimit_lt: Float
  totalLimit_lte: Float
  totalLimit_gt: Float
  totalLimit_gte: Float
  AND: [RollingCostCategoryWhereInput!]
  OR: [RollingCostCategoryWhereInput!]
  NOT: [RollingCostCategoryWhereInput!]
}

input RollingCostCategoryWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  cost(where: CostSubscriptionWhereInput): CostSubscriptionPayload
  financialMonth(where: FinancialMonthSubscriptionWhereInput): FinancialMonthSubscriptionPayload
  fixedCostCategory(where: FixedCostCategorySubscriptionWhereInput): FixedCostCategorySubscriptionPayload
  flexCostCategory(where: FlexCostCategorySubscriptionWhereInput): FlexCostCategorySubscriptionPayload
  monthlyIncome(where: MonthlyIncomeSubscriptionWhereInput): MonthlyIncomeSubscriptionPayload
  rollingCostCategory(where: RollingCostCategorySubscriptionWhereInput): RollingCostCategorySubscriptionPayload
}
`